# Вводная информация

- **Язык и парадигма.**  
  Для решения выбран **Prolog**: декларативное описание деревьев выражений и автоматический поиск по пространству состояний позволяют естественно перебрать допустимые комбинации из пяти двоек. Предикаты и унификация делают проверку ограничений (точно пять двоек, целевой результат, отсутствие деления на ноль) компактной и наглядной.
- **Алгоритм.**  
  Построение выражений происходит рекурсивно: базовый случай — литералы `2`, `22`, `222`, `2222`; составные выражения получаются комбинацией двух подвыражений бинарными операциями или применением квадрата.
- **Использование ИИ.**  
  ИИ использовался при рефакторинге кода и составлении документации.

# Реализация

- `twos_value/2` строит литералы `2`, `22`, `222`, `2222`, что даёт компактное внутреннее представление для листьев дерева выражения.
- Выражения описываются термами `lit/1`, `add/2`, `sub/2`, `mul/2`, `div/2`, `sq/1`. Предикат `expression_of_twos/3` рекурсивно перебирает допустимые деревья, контролируя точное число использованных двоек.
- `combine_expr/6` кладёт ограничения на коммутативные операции через `canonical_pair/2`, чтобы не перебирать симметричные варианты (`A + B` и `B + A`).
- `target_expression/2` ищет единственное выражение из пяти двоек, которое принимает требуемое целое значение, а `expr_to_string/2` минимизирует скобки и формирует человекочитаемую запись.
- Вспомогательный `main/2` позволяет получить строковое представление решения непосредственным вызовом из REPL или тестов.

# Запуск

```bash
swipl
```
```prolog
?- [twos].
?- twos:main(`YOUR_NUMBER`, Result).
```
